import React, { useState, useRef, useEffect, useCallback, Suspense } from 'react';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
// Lazy load the 3D component to avoid loading Three.js until needed
const RoomPlanner3D = React.lazy(() => import('./RoomPlanner3D').then(module => ({ default: module.RoomPlanner3D })));

import { 
  ArrowRight, Save, ZoomIn, ZoomOut, 
  Undo2, Trash2, Settings2, 
  Grid3X3, DoorOpen, MousePointer2, 
  PenTool, ArrowRightLeft, ArrowUpDown, 
  Ruler, RotateCw, ChevronUp, ChevronDown, X,
  FileText, Printer, LayoutTemplate,
  PaintBucket, Layers, Hammer, Camera, Globe,
  Share2, FolderHeart, Image as ImageIcon,
  Minimize2, Maximize2, AlignCenter, Calculator,
  Hand, Move, HelpCircle, Plus,
  Armchair, Sofa, Bed, Table, Box
} from 'lucide-react';

// --- Configuration ---
const GRID_SIZE = 20;
const SNAP_DISTANCE = 25; // Increased for better snapping
const DEFAULT_WALL_THICKNESS = 20;

// --- Types ---
type Point = { x: number, y: number };
type Wall = { id: string, startNodeId: string, endNodeId: string, thickness: number, height: number, length?: number }; // length is just cache
type WallObject = { id: string, wallId: string, type: 'DOOR' | 'WINDOW', t: number, width: number, height: number, flipX?: boolean, flipY?: boolean, leafCount?: 1 | 2, sillHeight?: number };
type Node = { id: string, x: number, y: number };
type Viewport = { x: number, y: number, zoom: number };

// NEW: Furniture Types
type FurnitureType = 'BED_SINGLE' | 'BED_DOUBLE' | 'SOFA' | 'TABLE_ROUND' | 'TABLE_RECT' | 'CHAIR' | 'TOILET' | 'SINK' | 'STOVE' | 'FRIDGE' | 'WARDROBE';

interface Furniture {
  id: string;
  type: FurnitureType;
  x: number;
  y: number;
  rotation: number; // radians
  width: number;
  depth: number;
}

// Furniture Templates
const FURNITURE_TEMPLATES: Record<FurnitureType, { width: number, depth: number, labelAr: string, labelEn: string, icon: any }> = {
  BED_SINGLE: { width: 90, depth: 200, labelAr: 'سرير مفرد', labelEn: 'Single Bed', icon: Bed },
  BED_DOUBLE: { width: 160, depth: 200, labelAr: 'سرير مزدوج', labelEn: 'Double Bed', icon: Bed },
  SOFA: { width: 220, depth: 90, labelAr: 'كنبة', labelEn: 'Sofa', icon: Sofa },
  TABLE_RECT: { width: 150, depth: 90, labelAr: 'طاولة طعام', labelEn: 'Dining Table', icon: Table },
  TABLE_ROUND: { width: 110, depth: 110, labelAr: 'طاولة دائرية', labelEn: 'Round Table', icon: Table },
  CHAIR: { width: 50, depth: 50, labelAr: 'كرسي', labelEn: 'Chair', icon: Armchair },
  WARDROBE: { width: 150, depth: 60, labelAr: 'خزانة ملابس', labelEn: 'Wardrobe', icon: Box },
  TOILET: { width: 45, depth: 70, labelAr: 'مرحاض', labelEn: 'Toilet', icon: Box },
  SINK: { width: 60, depth: 50, labelAr: 'مغسلة', labelEn: 'Sink', icon: Box },
  STOVE: { width: 60, depth: 60, labelAr: 'موقد', labelEn: 'Stove', icon: Box },
  FRIDGE: { width: 70, depth: 70, labelAr: 'ثلاجة', labelEn: 'Fridge', icon: Box },
};

// --- Translations ---
const TRANSLATIONS = {
  AR: {
    title: "مخطط الغرفة الذكي",
    wallProp: "خصائص الجدار",
    objProp: "خصائص العنصر",
    nodeProp: "خصائص النقطة",
    length: "طول الجدار",
    thickness: "سماكة الجدار",
    height: "الارتفاع",
    width: "العرض",
    depth: "العمق",
    saveOptions: "خيارات الحفظ",
    saveFile: "حفظ كملف مشروع",
    saveImg: "حفظ كصورة",
    shareApp: "مشاركة التطبيق",
    reportTitle: "تقرير الكميات والمواصفات",
    reportSub: "تم الإنشاء بواسطة بيت الريف",
    client: "اسم العميل",
    contractor: "المقاول المنفذ",
    gen: "عام",
    paint: "دهانات",
    floor: "أرضيات",
    loading: "جاري معالجة المخطط...",
    elevations: "واجهات الجدران",
    wall: "جدار",
    summary: "ملخص عام",
    summaryPaint: "ملخص الدهانات",
    summaryFloor: "ملخص الأرضيات",
    item: "البيان",
    unit: "الوحدة",
    qty: "الكمية",
    notes: "ملاحظات",
    floorArea: "مساحة الأرضية",
    skirting: "نعلات (وزرات)",
    paintWall: "دهان الجدران",
    paintCeiling: "دهان السقف",
    doorCount: "عدد الأبواب",
    windowCount: "عدد النوافذ",
    furnitureCount: "قطع الأثاث",
    footer: "هذا التقرير تقريبي ويجب مراجعته ميدانياً.",
    sign: "توقيع المهندس",
    stamp: "الختم",
    furniture: "الأثاث"
  },
  EN: {
    title: "Smart Room Planner",
    wallProp: "Wall Properties",
    objProp: "Object Properties",
    nodeProp: "Point Properties",
    length: "Length",
    thickness: "Thickness",
    height: "Height",
    width: "Width",
    depth: "Depth",
    saveOptions: "Save Options",
    saveFile: "Save Project File",
    saveImg: "Save as Image",
    shareApp: "Share App",
    reportTitle: "BoQ & Specs Report",
    reportSub: "Generated by Biet Alreef",
    client: "Client Name",
    contractor: "Contractor",
    gen: "General",
    paint: "Paint",
    floor: "Flooring",
    loading: "Processing Plan...",
    elevations: "Wall Elevations",
    wall: "Wall",
    summary: "General Summary",
    summaryPaint: "Paint Summary",
    summaryFloor: "Flooring Summary",
    item: "Item",
    unit: "Unit",
    qty: "Qty",
    notes: "Notes",
    floorArea: "Floor Area",
    skirting: "Skirting",
    paintWall: "Wall Paint",
    paintCeiling: "Ceiling Paint",
    doorCount: "Doors Count",
    windowCount: "Windows Count",
    furnitureCount: "Furniture Items",
    footer: "This report is approximate and must be verified on site.",
    sign: "Engineer Sign",
    stamp: "Stamp",
    furniture: "Furniture"
  }
};

const COLORS = {
  bg: '#ffffff', 
  grid: '#e2e8f0',
  wallFill: '#bfdbfe', // Darker Blue Fill (Blue 200)
  wallStroke: '#1e40af', // Darker Blue Stroke (Blue 800)
  wallSelected: '#ef4444', // Red
  node: '#ffffff',
  nodeStroke: '#1e40af', // Match Wall Stroke
  doorStroke: '#ef4444', 
  windowGlass: '#93c5fd', // Darker Glass
  handle: '#fbbf24',
  dimLineInactive: '#475569',
  dimLineActive: '#2563eb',
  dimText: '#0f172a', 
  dimTextBg: '#ffffff',
  furnitureFill: '#e0e7ff', // Indigo 100
  furnitureStroke: '#4338ca', // Indigo 700
  furnitureSelected: '#ef4444'
};

export function RoomPlanner2DLogic({ onBack, initialData }: { onBack: () => void, initialData?: any }) {
  // --- State ---
  const [lang, setLang] = useState<'AR'|'EN'>('AR');
  const t = TRANSLATIONS[lang];
  
  const [nodes, setNodes] = useState<Node[]>(initialData?.nodes || []);
  const [walls, setWalls] = useState<Wall[]>(initialData?.walls || []);
  const [objects, setObjects] = useState<WallObject[]>(initialData?.objects || []);
  // NEW: Furniture State
  const [furniture, setFurniture] = useState<Furniture[]>(initialData?.furniture || []);
  
  const [viewport, setViewport] = useState<Viewport>({ x: 0, y: 0, zoom: 1 });
  const [mode, setMode] = useState<'SELECT' | 'DRAW' | 'PAN' | 'RECT' | 'ROTATE' | 'FURNITURE'>('DRAW');
  const [selectedId, setSelectedId] = useState<{ type: 'WALL' | 'OBJECT' | 'NODE' | 'FURNITURE', id: string } | null>(null);
  const [history, setHistory] = useState<string[]>([]);
  const [showSaveMenu, setShowSaveMenu] = useState(false);
  const [showHelp, setShowHelp] = useState(false);
  const [showReport, setShowReport] = useState(false);
  const [show3D, setShow3D] = useState(false);
  const [reportData, setReportData] = useState({ clientName: '', contractorName: '' });
  const [reportFilter, setReportFilter] = useState<'GENERAL'|'PAINT'|'FLOOR'>('GENERAL');
  const [planSnapshot, setPlanSnapshot] = useState<string | null>(null);
  const [cursorPos, setCursorPos] = useState<Point | null>(null); // For architectural guides
  const [showFurnitureMenu, setShowFurnitureMenu] = useState(false); // New menu state
  
  // Export state
  const isExportingRef = useRef(false);

  // Interaction Refs
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const isDraggingRef = useRef(false);
  const dragStartRef = useRef({ x: 0, y: 0 });
  const activeObjRef = useRef<string | 'PAN' | 'RECT' | null>(null);
  const drawingStartNodeRef = useRef<string | null>(null);
  const [tempWallEnd, setTempWallEnd] = useState<Point | null>(null);
  const [tempRectEnd, setTempRectEnd] = useState<Point | null>(null); // NEW: For Rectangle Tool
  const [startNodePreview, setStartNodePreview] = useState<Point | null>(null);
  const [contextMenuPos, setContextMenuPos] = useState<{x: number, y: number} | null>(null);
  const [showProps, setShowProps] = useState(false);
  // NEW: Measurement Mode State
  const [measureMode, setMeasureMode] = useState<'INNER'|'CENTER'|'OUTER'>('CENTER');
  
  const snapshotPendingRef = useRef(false);

  const rotationRef = useRef<{ active: boolean, startAngle: number, center: Point }>({ active: false, startAngle: 0, center: {x:0,y:0} });

  // --- History ---
  const saveHistory = () => {
    const state = JSON.stringify({ nodes, walls, objects, furniture });
    if (history[history.length - 1] !== state) {
      setHistory(h => [...h.slice(-10), state]);
    }
  };
  const undo = () => {
    if (history.length > 0) {
      const prev = history[history.length - 1];
      const data = JSON.parse(prev);
      setNodes(data.nodes); setWalls(data.walls); setObjects(data.objects);
      if (data.furniture) setFurniture(data.furniture); // Handle furniture undo
      setHistory(h => h.slice(0, -1));
    }
  };

  // --- Helpers ---
  const toWorld = (sx: number, sy: number) => ({ x: (sx - viewport.x) / viewport.zoom, y: (sy - viewport.y) / viewport.zoom });
  const toScreen = (wx: number, wy: number) => ({ x: wx * viewport.zoom + viewport.x, y: wy * viewport.zoom + viewport.y });
  const dist = (p1: Point, p2: Point) => Math.hypot(p2.x - p1.x, p2.y - p1.y);
  
  const getMousePos = (e: any) => {
    const r = canvasRef.current!.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - r.left, y: clientY - r.top };
  };

  const findNodeAt = (p: Point, radius = 10) => nodes.find(n => dist(n, p) < radius / viewport.zoom);
  
  const calculateStats = () => {
     let floorAreaM2 = 0;
     let wallLengthM = 0;
     let doorCount = 0;
     let windowCount = 0;
     
     walls.forEach(w => {
        const n1 = nodes.find(n => n.id === w.startNodeId);
        const n2 = nodes.find(n => n.id === w.endNodeId);
        if(n1 && n2) wallLengthM += dist(n1, n2);
     });
     
     if (nodes.length > 2) {
         let area = 0;
         for (let i = 0; i < nodes.length; i++) {
             const j = (i + 1) % nodes.length;
             area += nodes[i].x * nodes[j].y;
             area -= nodes[j].x * nodes[i].y;
         }
         floorAreaM2 = Math.abs(area / 2) / 10000; // cm2 to m2
     }

     doorCount = objects.filter(o => o.type === 'DOOR').length;
     windowCount = objects.filter(o => o.type === 'WINDOW').length;
     const furnitureCount = furniture.length;
     
     const wallAreaM2 = (wallLengthM * 2.8) / 100; // Assume 2.8m height
     const netPaintAreaM2 = wallAreaM2 - (doorCount * 2 + windowCount * 1.5); 

     return { 
         floorAreaM2: floorAreaM2.toFixed(2), 
         wallLengthM: (wallLengthM/100).toFixed(2), 
         ceilingAreaM2: floorAreaM2.toFixed(2),
         netPaintAreaM2: netPaintAreaM2.toFixed(2),
         doorCount, 
         windowCount,
         furnitureCount
     };
  };

  const handleSaveToFiles = () => {
      const data = JSON.stringify({ nodes, walls, objects, furniture, version: '1.1' });
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `plan-${new Date().toISOString().slice(0,10)}.json`;
      a.click(); setShowSaveMenu(false);
  };

  const handleSaveImage = () => {
      isExportingRef.current = true;
      draw(); 
      const link = document.createElement('a');
      link.download = `room-plan-${Date.now()}.png`;
      link.href = canvasRef.current!.toDataURL();
      link.click();
      isExportingRef.current = false;
      draw();
      setShowSaveMenu(false);
  };

  const handleShare = async () => {
     if (navigator.share) {
        try {
            const file = new File([JSON.stringify({ nodes, walls, objects, furniture })], 'plan.json', { type: 'application/json' });
            await navigator.share({ title: 'My Room Plan', text: 'Check out my room plan!', files: [file] });
        } catch (e) { console.log('Share failed', e); }
     } else { alert('Sharing not supported on this device'); }
  };

  const openReport = () => {
     document.title = reportData.clientName ? `Report_${reportData.clientName}` : "Engineering_Report";
     if (nodes.length > 0 && canvasRef.current) {
         const minX = Math.min(...nodes.map(n => n.x));
         const maxX = Math.max(...nodes.map(n => n.x));
         const minY = Math.min(...nodes.map(n => n.y));
         const maxY = Math.max(...nodes.map(n => n.y));
         
         const padding = 100; 
         const worldW = (maxX - minX) + padding * 2;
         const worldH = (maxY - minY) + padding * 2;
         
         const cvsW = canvasRef.current.width;
         const cvsH = canvasRef.current.height;
         
         const fitZoom = Math.min(cvsW / worldW, cvsH / worldH) * 0.9; 
         const clampedZoom = Math.min(Math.max(fitZoom, 0.2), 2.0); 
         
         const worldCx = (minX + maxX) / 2;
         const worldCy = (minY + maxY) / 2;
         
         const newVx = (cvsW / 2) - (worldCx * clampedZoom);
         const newVy = (cvsH / 2) - (worldCy * clampedZoom);
         
         setViewport({ x: newVx, y: newVy, zoom: clampedZoom });
         
         isExportingRef.current = true;
         snapshotPendingRef.current = true;
     } else {
         setShowReport(true);
     }
  };

  const addFurniture = (type: FurnitureType) => {
      // Add to center of screen
      const center = toWorld(canvasRef.current!.width / 2, canvasRef.current!.height / 2);
      const tmpl = FURNITURE_TEMPLATES[type];
      const newFurn: Furniture = {
          id: Math.random().toString(),
          type: type,
          x: center.x,
          y: center.y,
          rotation: 0,
          width: tmpl.width,
          depth: tmpl.depth
      };
      setFurniture(prev => [...prev, newFurn]);
      setMode('SELECT');
      setSelectedId({ type: 'FURNITURE', id: newFurn.id });
      setShowFurnitureMenu(false);
      setShowProps(true);
      saveHistory();
  };

  // --- Input Handlers ---
  const handlePointerDown = (e: any) => {
    const pos = getMousePos(e);
    const wPos = toWorld(pos.x, pos.y);
    
    // NEW: Hit test for Furniture
    // We need to account for rotation to check hit accurately, but for simplicity we'll use a bounding circle radius check first
    for (let i = furniture.length - 1; i >= 0; i--) {
        const f = furniture[i];
        const radius = Math.max(f.width, f.depth) / 2;
        if (dist(wPos, {x: f.x, y: f.y}) < radius) {
            setSelectedId({ type: 'FURNITURE', id: f.id });
            activeObjRef.current = f.id;
            isDraggingRef.current = true;
            dragStartRef.current = pos; // Screen pos for drag delta
            setShowProps(true);
            return;
        }
    }

    const clickedNode = findNodeAt(wPos);
    if (clickedNode) {
      if (mode === 'SELECT') { setSelectedId({ type: 'NODE', id: clickedNode.id }); activeObjRef.current = clickedNode.id; setShowProps(true); }
      else if (mode === 'DRAW') { drawingStartNodeRef.current = clickedNode.id; setStartNodePreview({ x: clickedNode.x, y: clickedNode.y }); setTempWallEnd(wPos); }
      isDraggingRef.current = true; dragStartRef.current = pos;
      return;
    }
    
    const clickedObj = objects.find(o => {
       const wall = walls.find(w => w.id === o.wallId);
       if (!wall) return false;
       const n1 = nodes.find(n => n.id === wall.startNodeId);
       const n2 = nodes.find(n => n.id === wall.endNodeId);
       if (!n1 || !n2) return false;
       const cx = n1.x + (n2.x - n1.x) * o.t;
       const cy = n1.y + (n2.y - n1.y) * o.t;
       return dist(wPos, {x: cx, y: cy}) < (o.width/2 + 10);
    });
    
    if (clickedObj) {
       setSelectedId({ type: 'OBJECT', id: clickedObj.id });
       if (mode === 'SELECT') { 
          activeObjRef.current = clickedObj.id; 
          setShowProps(true); 
       }
       isDraggingRef.current = true; dragStartRef.current = pos;
       return;
    }

    if (mode === 'PAN') {
       activeObjRef.current = 'PAN';
       isDraggingRef.current = true; dragStartRef.current = pos;
       return;
    }
    if (mode === 'RECT') {
        activeObjRef.current = 'RECT';
        isDraggingRef.current = true;
        dragStartRef.current = pos; 
        return;
    }

    if (mode === 'ROTATE') {
       activeObjRef.current = 'ROTATE_PLAN';
       isDraggingRef.current = true;
       dragStartRef.current = pos;
       return;
    }

    const clickedWall = walls.find(w => {
      const n1 = nodes.find(n => n.id === w.startNodeId);
      const n2 = nodes.find(n => n.id === w.endNodeId);
      if (!n1 || !n2) return false;
      const l2 = dist(n1, n2) ** 2;
      if (l2 === 0) return false;
      const t = ((wPos.x - n1.x)*(n2.x - n1.x) + (wPos.y - n1.y)*(n2.y - n1.y)) / l2;
      if (t < 0 || t > 1) return false;
      const proj = { x: n1.x + t*(n2.x - n1.x), y: n1.y + t*(n2.y - n1.y) };
      return dist(wPos, proj) < (w.thickness/2 + 20);
    });
    if (clickedWall) {
      setSelectedId({ type: 'WALL', id: clickedWall.id });
      if (mode === 'SELECT') { 
          activeObjRef.current = clickedWall.id;
          isDraggingRef.current = true; 
          dragStartRef.current = pos;
          setShowProps(true); 
      }
      return;
    }
    if (mode === 'DRAW') {
      const newNodeId = Math.random().toString();
      const newNode = { id: newNodeId, x: wPos.x, y: wPos.y };
      setNodes(prev => [...prev, newNode]);
      drawingStartNodeRef.current = newNodeId;
      setStartNodePreview({ x: wPos.x, y: wPos.y });
      setTempWallEnd(wPos);
    } else { setSelectedId(null); activeObjRef.current = 'PAN'; isDraggingRef.current = true; dragStartRef.current = pos; } // Default to PAN if click empty space
  };

  const handlePointerMove = (e: any) => {
    const pos = getMousePos(e);
    const wPos = toWorld(pos.x, pos.y);

    if (!isDraggingRef.current) {
       if (mode === 'DRAW') {
          const snapNode = findNodeAt(wPos, SNAP_DISTANCE);
          if (snapNode) setCursorPos({x: snapNode.x, y: snapNode.y});
          else setCursorPos(wPos);
       } else {
          setCursorPos(wPos);
       }
    }

    if (!isDraggingRef.current || showReport || showSaveMenu) return;

    if (activeObjRef.current === 'PAN') {
      const dx = pos.x - dragStartRef.current.x;
      const dy = pos.y - dragStartRef.current.y;
      setViewport(v => ({ ...v, x: v.x + dx, y: v.y + dy }));
      dragStartRef.current = pos;
      return;
    }
    
    // Furniture Move
    if (selectedId?.type === 'FURNITURE' && activeObjRef.current === selectedId.id) {
         const prevWPos = toWorld(dragStartRef.current.x, dragStartRef.current.y);
         const dx = wPos.x - prevWPos.x;
         const dy = wPos.y - prevWPos.y;
         
         setFurniture(prev => prev.map(f => f.id === selectedId.id ? { ...f, x: f.x + dx, y: f.y + dy } : f));
         dragStartRef.current = pos;
         return;
    }

    if (activeObjRef.current === 'RECT') {
        setTempRectEnd(wPos);
        return;
    }
    
    if (activeObjRef.current === 'ROTATE_PLAN') {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        if (nodes.length === 0) return;
        nodes.forEach(n => {
            if(n.x < minX) minX = n.x; if(n.x > maxX) maxX = n.x;
            if(n.y < minY) minY = n.y; if(n.y > maxY) maxY = n.y;
        });
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        
        const sCenter = toScreen(cx, cy);
        
        const prevAngle = Math.atan2(dragStartRef.current.y - sCenter.y, dragStartRef.current.x - sCenter.x);
        const curAngle = Math.atan2(pos.y - sCenter.y, pos.x - sCenter.x);
        const delta = curAngle - prevAngle;
        
        if (delta !== 0) {
            const cos = Math.cos(delta);
            const sin = Math.sin(delta);
            
            setNodes(prev => prev.map(n => {
                const nx = n.x - cx;
                const ny = n.y - cy;
                return {
                    ...n,
                    x: cx + (nx * cos - ny * sin),
                    y: cy + (nx * sin + ny * cos)
                };
            }));
            
            // Also rotate furniture
            setFurniture(prev => prev.map(f => {
                const nx = f.x - cx;
                const ny = f.y - cy;
                return {
                    ...f,
                    x: cx + (nx * cos - ny * sin),
                    y: cy + (nx * sin + ny * cos),
                    rotation: f.rotation + delta
                };
            }));

            dragStartRef.current = pos;
        }
        return;
    }

    if (mode === 'DRAW' && drawingStartNodeRef.current) {
      let target = { ...wPos };
      const startNode = nodes.find(n => n.id === drawingStartNodeRef.current) || startNodePreview;
      if (startNode) {
        const dx = Math.abs(target.x - startNode.x);
        const dy = Math.abs(target.y - startNode.y);
        if (dx < 20 / viewport.zoom) target.x = startNode.x; 
        if (dy < 20 / viewport.zoom) target.y = startNode.y; 
      }
      const snapNode = findNodeAt(target, SNAP_DISTANCE);
      if (snapNode && snapNode.id !== drawingStartNodeRef.current) { target = { x: snapNode.x, y: snapNode.y }; }
      
      if (startNode) {
          const dist = Math.hypot(target.x - startNode.x, target.y - startNode.y);
          if (dist > 800) {
              const angle = Math.atan2(target.y - startNode.y, target.x - startNode.x);
              target.x = startNode.x + Math.cos(angle) * 800;
              target.y = startNode.y + Math.sin(angle) * 800;
          }
      }

      setTempWallEnd(target);
      return;
    }
    if (mode === 'SELECT' && activeObjRef.current && nodes.find(n => n.id === activeObjRef.current)) {
      const nodeId = activeObjRef.current;
      setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, x: wPos.x, y: wPos.y } : n));
      return;
    }
    if (mode === 'SELECT' && activeObjRef.current && objects.find(o => o.id === activeObjRef.current)) {
      const objId = activeObjRef.current;
      const obj = objects.find(o => o.id === objId);
      if (!obj) return;
      const wall = walls.find(w => w.id === obj.wallId);
      if (!wall) return;
      const n1 = nodes.find(n => n.id === wall.startNodeId);
      const n2 = nodes.find(n => n.id === wall.endNodeId);
      if (!n1 || !n2) return;
      const dx = n2.x - n1.x; const dy = n2.y - n1.y; const len2 = dx*dx + dy*dy;
      let t = ((wPos.x - n1.x)*dx + (wPos.y - n1.y)*dy) / len2;
      const wallLen = Math.sqrt(len2); const halfWidthT = (obj.width / 2) / wallLen;
      t = Math.max(halfWidthT, Math.min(1 - halfWidthT, t)); 
      setObjects(prev => prev.map(o => o.id === objId ? { ...o, t } : o));
      return;
    }
    
    if (mode === 'SELECT' && activeObjRef.current && walls.find(w => w.id === activeObjRef.current)) {
        const wId = activeObjRef.current;
        const draggingWall = walls.find(w => w.id === wId);
        if (draggingWall) {
             const prevWPos = toWorld(dragStartRef.current.x, dragStartRef.current.y);
             const dx = wPos.x - prevWPos.x;
             const dy = wPos.y - prevWPos.y;

             setNodes(prev => prev.map(n => {
                 if (n.id === draggingWall.startNodeId || n.id === draggingWall.endNodeId) {
                     return { ...n, x: n.x + dx, y: n.y + dy };
                 }
                 return n;
             }));
             dragStartRef.current = pos;
        }
        return;
    }
  };

  const handlePointerUp = () => {
    if (activeObjRef.current === 'RECT' && tempRectEnd) {
        const startPos = toWorld(dragStartRef.current.x, dragStartRef.current.y);
        const endPos = tempRectEnd;
        
        const width = Math.abs(endPos.x - startPos.x);
        const height = Math.abs(endPos.y - startPos.y);
        
        if (width > 50 && height > 50) {
            const n1 = { id: Math.random().toString(), x: startPos.x, y: startPos.y };
            const n2 = { id: Math.random().toString(), x: endPos.x, y: startPos.y };
            const n3 = { id: Math.random().toString(), x: endPos.x, y: endPos.y };
            const n4 = { id: Math.random().toString(), x: startPos.x, y: endPos.y };
            
            const w1 = { id: Math.random().toString(), startNodeId: n1.id, endNodeId: n2.id, thickness: DEFAULT_WALL_THICKNESS, height: 280 };
            const w2 = { id: Math.random().toString(), startNodeId: n2.id, endNodeId: n3.id, thickness: DEFAULT_WALL_THICKNESS, height: 280 };
            const w3 = { id: Math.random().toString(), startNodeId: n3.id, endNodeId: n4.id, thickness: DEFAULT_WALL_THICKNESS, height: 280 };
            const w4 = { id: Math.random().toString(), startNodeId: n4.id, endNodeId: n1.id, thickness: DEFAULT_WALL_THICKNESS, height: 280 };
            
            setNodes(prev => [...prev, n1, n2, n3, n4]);
            setWalls(prev => [...prev, w1, w2, w3, w4]);
            saveHistory();
        }
        
        setTempRectEnd(null);
        activeObjRef.current = null;
        isDraggingRef.current = false;
        setMode('SELECT'); 
        return;
    }

    isDraggingRef.current = false; activeObjRef.current = null; rotationRef.current.active = false;
    if (mode === 'DRAW' && drawingStartNodeRef.current && tempWallEnd) {
      let endNodeId = ''; const snapNode = findNodeAt(tempWallEnd, SNAP_DISTANCE);
      if (snapNode) { endNodeId = snapNode.id; } 
      else { 
          const dist = Math.hypot(tempWallEnd.x - startNodePreview!.x, tempWallEnd.y - startNodePreview!.y);
          if (dist < 50) {
              setTempWallEnd(null); setStartNodePreview(null); drawingStartNodeRef.current = null;
              return;
          }
          const newNode = { id: Math.random().toString(), x: tempWallEnd.x, y: tempWallEnd.y }; setNodes(prev => [...prev, newNode]); endNodeId = newNode.id; 
      }
      
      if (drawingStartNodeRef.current !== endNodeId) {
        const startNode = nodes.find(n => n.id === drawingStartNodeRef.current);
        const endNode = nodes.find(n => n.id === endNodeId) || { x: tempWallEnd.x, y: tempWallEnd.y };
        if(startNode) {
             const dist = Math.hypot(endNode.x - startNode.x, endNode.y - startNode.y);
             if (dist > 50) {
                 const newWall: Wall = { id: Math.random().toString(), startNodeId: drawingStartNodeRef.current, endNodeId: endNodeId, thickness: DEFAULT_WALL_THICKNESS, height: 280 };
                 setWalls(prev => [...prev, newWall]); saveHistory(); drawingStartNodeRef.current = endNodeId; setStartNodePreview({ x: tempWallEnd.x, y: tempWallEnd.y });
             } else {
                 if (!snapNode) drawingStartNodeRef.current = null; 
             }
        }
      } else { drawingStartNodeRef.current = null; }
    } else { if (mode === 'DRAW' && !isDraggingRef.current) { drawingStartNodeRef.current = null; } }
    if (mode !== 'DRAW') { setTempWallEnd(null); setStartNodePreview(null); }
  };

  const draw = useCallback(() => {
    const cvs = canvasRef.current; if (!cvs) return; const ctx = cvs.getContext('2d'); if (!ctx) return;
    
    if (isExportingRef.current) {
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(0, 0, cvs.width, cvs.height);
    } else {
        ctx.fillStyle = COLORS.bg; 
        ctx.fillRect(0, 0, cvs.width, cvs.height);
        
        ctx.beginPath(); ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 1;
        const sx = Math.floor(toWorld(0,0).x / GRID_SIZE) * GRID_SIZE; const ex = Math.floor(toWorld(cvs.width,0).x / GRID_SIZE) * GRID_SIZE;
        const sy = Math.floor(toWorld(0,0).y / GRID_SIZE) * GRID_SIZE; const ey = Math.floor(toWorld(0,cvs.height).y / GRID_SIZE) * GRID_SIZE;
        for(let x=sx; x<=ex; x+=GRID_SIZE) { const s = toScreen(x,0); ctx.moveTo(s.x, 0); ctx.lineTo(s.x, cvs.height); }
        for(let y=sy; y<=ey; y+=GRID_SIZE) { const s = toScreen(0,y); ctx.moveTo(0, s.y); ctx.lineTo(cvs.width, s.y); }
        ctx.stroke();
    }
    
    const zoom = viewport.zoom;

    // 1. Draw Walls
    walls.forEach(w => {
      const n1 = nodes.find(n => n.id === w.startNodeId); const n2 = nodes.find(n => n.id === w.endNodeId); if (!n1 || !n2) return;
      const s1 = toScreen(n1.x, n1.y); const s2 = toScreen(n2.x, n2.y);
      const isSel = selectedId?.type === 'WALL' && selectedId.id === w.id; const th = w.thickness * zoom;
      
      ctx.lineCap = 'butt'; 
      ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y);
      ctx.lineWidth = th; ctx.strokeStyle = isSel ? COLORS.wallSelected : COLORS.wallFill; ctx.stroke();
      if (!isSel) {
          const dx = s2.x - s1.x; const dy = s2.y - s1.y; const len = Math.hypot(dx, dy);
          const nx = -dy/len; const ny = dx/len;
          ctx.beginPath(); 
          ctx.lineWidth = 1; ctx.strokeStyle = COLORS.wallStroke;
          ctx.moveTo(s1.x + nx*th/2, s1.y + ny*th/2); ctx.lineTo(s2.x + nx*th/2, s2.y + ny*th/2);
          ctx.moveTo(s1.x - nx*th/2, s1.y - ny*th/2); ctx.lineTo(s2.x - nx*th/2, s2.y - ny*th/2);
          ctx.stroke();
      }

      const dx = s2.x - s1.x; const dy = s2.y - s1.y; const len = Math.hypot(dx, dy); const nx = -dy/len; const ny = dx/len; 
      const wallObjs = objects.filter(o => o.wallId === w.id).sort((a,b) => a.t - b.t); const wallLenWorld = Math.hypot(n2.x-n1.x, n2.y-n1.y);
      
      const isWallSelected = selectedId?.type === 'WALL' && selectedId.id === w.id;
      const activeMode = isWallSelected ? measureMode : null; 

      const p1Outer = { x: s1.x + nx * (th/2), y: s1.y + ny * (th/2) };
      const p2Outer = { x: s2.x + nx * (th/2), y: s2.y + ny * (th/2) };
      const p1Inner = { x: s1.x - nx * (th/2), y: s1.y - ny * (th/2) };
      const p2Inner = { x: s2.x - nx * (th/2), y: s2.y - ny * (th/2) };

      if (wallObjs.length === 0) { 
          drawDimension(ctx, p1Outer, p2Outer, nx, ny, 25, wallLenWorld + w.thickness, 'OUTER', activeMode === 'OUTER'); 
      } else {
        let currentT = 0;
        wallObjs.forEach(obj => {
            const objHalfWidthT = (obj.width / 2) / wallLenWorld; const objStartT = obj.t - objHalfWidthT; const objEndT = obj.t + objHalfWidthT;
            if (objStartT > currentT) { 
                const pStart = { x: p1Outer.x + dx*currentT, y: p1Outer.y + dy*currentT }; 
                const pEnd = { x: p1Outer.x + dx*objStartT, y: p1Outer.y + dy*objStartT }; 
                drawDimension(ctx, pStart, pEnd, nx, ny, 25, (objStartT - currentT) * wallLenWorld, 'OUTER', false); 
            }
            const pObjStart = { x: p1Outer.x + dx*objStartT, y: p1Outer.y + dy*objStartT }; 
            const pObjEnd = { x: p1Outer.x + dx*objEndT, y: p1Outer.y + dy*objEndT }; 
            drawDimension(ctx, pObjStart, pObjEnd, nx, ny, 25, obj.width, 'OUTER', false); currentT = objEndT;
        });
        if (currentT < 1.0) { 
            const pStart = { x: p1Outer.x + dx*currentT, y: p1Outer.y + dy*currentT }; 
            drawDimension(ctx, pStart, p2Outer, nx, ny, 25, (1.0 - currentT) * wallLenWorld, 'OUTER', false); 
        }
        if (isWallSelected && activeMode === 'OUTER') {
             drawDimension(ctx, p1Outer, p2Outer, nx, ny, 45, wallLenWorld + w.thickness, 'OUTER', true);
        }
      }
      const innerLen = Math.max(0, wallLenWorld - w.thickness); 
      drawDimension(ctx, p1Inner, p2Inner, -nx, -ny, 25, innerLen, 'INNER', activeMode === 'INNER');
      if (activeMode === 'CENTER') {
          drawDimension(ctx, s1, s2, nx, ny, 0, wallLenWorld, 'CENTER', true);
      }
    });

    // 2. Draw Objects (Doors/Windows)
    objects.forEach(obj => {
      const wall = walls.find(w => w.id === obj.wallId); if (!wall) return; const n1 = nodes.find(n => n.id === wall.startNodeId); const n2 = nodes.find(n => n.id === wall.endNodeId); if (!n1 || !n2) return;
      const s1 = toScreen(n1.x, n1.y); const s2 = toScreen(n2.x, n2.y); const dx = s2.x - s1.x; const dy = s2.y - s1.y; const cx = s1.x + dx * obj.t; const cy = s1.y + dy * obj.t;
      const angle = Math.atan2(dy, dx); const width = obj.width * zoom; const th = wall.thickness * zoom; const isSel = selectedId?.type === 'OBJECT' && selectedId.id === obj.id;
      ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle); ctx.globalCompositeOperation = 'source-over'; 
      ctx.fillStyle = COLORS.bg; ctx.fillRect(-width/2, -th/2-2, width, th+4);
      if (obj.type === 'DOOR') {
        const flipX = obj.flipX ? -1 : 1; const flipY = obj.flipY ? -1 : 1;
        ctx.fillStyle = COLORS.wallStroke; ctx.fillRect(-width/2, -th/2, 4, th); ctx.fillRect(width/2 - 4, -th/2, 4, th);
        const isDouble = obj.leafCount === 2;
        if (!isDouble) {
            const hingeX = (width/2) * flipX; const hingeY = (th/2) * flipY; 
            ctx.save(); ctx.translate(hingeX, hingeY); 
            const swingDir = flipX * flipY; const startAngle = flipX === 1 ? Math.PI : 0; const endAngle = startAngle + (Math.PI/2 * swingDir * -1); 
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(endAngle)*width, Math.sin(endAngle)*width);
            ctx.lineWidth = 2; ctx.strokeStyle = isSel ? COLORS.wallSelected : COLORS.doorStroke; ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, width, startAngle, endAngle, swingDir > 0);
            ctx.setLineDash([5, 3]); ctx.lineWidth = 1; ctx.strokeStyle = '#ef4444'; ctx.stroke(); ctx.setLineDash([]);
            ctx.restore();
        } else {
            const leafWidth = width / 2;
            ctx.save(); ctx.translate(-width/2, (th/2) * flipY);
            const swingL = flipY === 1 ? 1 : -1; 
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(swingL * Math.PI/2)*leafWidth, Math.sin(swingL * Math.PI/2)*leafWidth);
            ctx.lineWidth = 2; ctx.strokeStyle = isSel ? COLORS.wallSelected : COLORS.doorStroke; ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, leafWidth, 0, swingL * Math.PI/2, swingL > 0);
            ctx.setLineDash([5, 3]); ctx.lineWidth = 1; ctx.strokeStyle = '#ef4444'; ctx.stroke(); ctx.setLineDash([]);
            ctx.restore();
            ctx.save(); ctx.translate(width/2, (th/2) * flipY);
            const swingR = flipY === 1 ? 1 : -1; 
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(Math.PI + swingR * Math.PI/2)*leafWidth, Math.sin(Math.PI + swingR * Math.PI/2)*leafWidth);
            ctx.lineWidth = 2; ctx.strokeStyle = isSel ? COLORS.wallSelected : COLORS.doorStroke; ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, leafWidth, Math.PI, Math.PI + (swingR * Math.PI/2), swingR > 0);
            ctx.setLineDash([5, 3]); ctx.lineWidth = 1; ctx.strokeStyle = '#ef4444'; ctx.stroke(); ctx.setLineDash([]);
            ctx.restore();
        }
      } else {
        ctx.fillStyle = 'white'; ctx.fillRect(-width/2, -th/2, width, th); ctx.strokeStyle = '#888'; ctx.strokeRect(-width/2, -th/2, width, th); ctx.fillStyle = COLORS.windowGlass; ctx.fillRect(-width/2, -2, width, 4);
      }
      if (isSel) { ctx.fillStyle = COLORS.handle; ctx.fillRect(-15, th/2 + 5, 30, 4); ctx.strokeRect(-25, th/2+5, 50, 4); }
      ctx.restore();
    });

    // 3. Draw Nodes
    nodes.forEach(n => {
        const s = toScreen(n.x, n.y); 
        const connectedWalls = walls.filter(w => w.startNodeId === n.id || w.endNodeId === n.id);
        if (connectedWalls.length > 0) {
            const maxTh = Math.max(...connectedWalls.map(w => w.thickness));
            ctx.beginPath(); ctx.arc(s.x, s.y, (maxTh/2) * zoom, 0, Math.PI*2); ctx.fillStyle = COLORS.wallFill; ctx.fill();
            if (!isExportingRef.current) { ctx.lineWidth = 1; ctx.strokeStyle = COLORS.wallStroke; ctx.stroke(); }
        }
        if (!isExportingRef.current) {
            const isSel = selectedId?.type === 'NODE' && selectedId.id === n.id;
            const isHover = cursorPos && Math.hypot(n.x - cursorPos.x, n.y - cursorPos.y) < (SNAP_DISTANCE + 10) / viewport.zoom;
            if (isSel || isHover || mode === 'DRAW') {
                ctx.beginPath(); ctx.arc(s.x, s.y, (isSel || isHover ? 6 : 4) * zoom, 0, Math.PI*2); 
                ctx.fillStyle = COLORS.node; ctx.fill(); 
                ctx.lineWidth = 2; ctx.strokeStyle = isSel ? COLORS.wallSelected : COLORS.nodeStroke; ctx.stroke();
            }
        }
    });

    // 4. Draw Furniture
    furniture.forEach(f => {
       const s = toScreen(f.x, f.y);
       const isSel = selectedId?.type === 'FURNITURE' && selectedId.id === f.id;
       const width = f.width * zoom;
       const depth = f.depth * zoom;
       
       ctx.save();
       ctx.translate(s.x, s.y);
       ctx.rotate(f.rotation);
       
       // Draw Shadow
       ctx.shadowColor = 'rgba(0,0,0,0.1)';
       ctx.shadowBlur = 10;
       ctx.shadowOffsetY = 5;

       // Base Shape
       ctx.fillStyle = COLORS.furnitureFill;
       ctx.strokeStyle = isSel ? COLORS.furnitureSelected : COLORS.furnitureStroke;
       ctx.lineWidth = isSel ? 2 : 1;
       
       // Different Shapes per Type
       if (f.type.includes('ROUND') || f.type === 'TOILET') {
           ctx.beginPath();
           ctx.ellipse(0, 0, width/2, depth/2, 0, 0, Math.PI * 2);
           ctx.fill();
           ctx.stroke();
       } else {
           ctx.fillRect(-width/2, -depth/2, width, depth);
           ctx.strokeRect(-width/2, -depth/2, width, depth);
       }
       
       // Details
       ctx.shadowColor = 'transparent';
       ctx.fillStyle = COLORS.furnitureStroke;
       ctx.globalAlpha = 0.5;
       
       if (f.type.includes('BED')) {
           // Pillows
           const pillowSize = Math.min(width, depth) * 0.3;
           ctx.fillRect(-width/2 + 5, -depth/2 + 5, pillowSize, pillowSize*0.6);
           if (f.type === 'BED_DOUBLE') {
               ctx.fillRect(width/2 - 5 - pillowSize, -depth/2 + 5, pillowSize, pillowSize*0.6);
           }
           // Blanket line
           ctx.beginPath();
           ctx.moveTo(-width/2, 0); ctx.lineTo(width/2, 0);
           ctx.stroke();
       }
       else if (f.type.includes('TABLE')) {
           // Center
           ctx.beginPath();
           ctx.arc(0,0, 2, 0, Math.PI*2);
           ctx.fill();
       }
       else if (f.type === 'TOILET') {
           // Tank
           ctx.fillRect(-width/2, -depth/2, width, depth*0.3);
       }

       ctx.globalAlpha = 1;
       ctx.restore();
       
       // Selection Box
       if (isSel) {
           ctx.save();
           ctx.translate(s.x, s.y);
           ctx.rotate(f.rotation);
           ctx.strokeStyle = '#ef4444';
           ctx.lineWidth = 1;
           ctx.setLineDash([5, 3]);
           ctx.strokeRect(-width/2 - 5, -depth/2 - 5, width + 10, depth + 10);
           ctx.setLineDash([]);
           // Rotation Handle
           ctx.beginPath();
           ctx.arc(0, -depth/2 - 20, 5, 0, Math.PI*2);
           ctx.fillStyle = '#ef4444';
           ctx.fill();
           ctx.moveTo(0, -depth/2 - 5); ctx.lineTo(0, -depth/2 - 20); ctx.stroke();
           ctx.restore();
       }
    });

    if (mode === 'DRAW' && cursorPos) {
       const s = toScreen(cursorPos.x, cursorPos.y);
       ctx.beginPath(); ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)'; ctx.lineWidth = 1; ctx.setLineDash([10, 5]); 
       ctx.moveTo(s.x, 0); ctx.lineTo(s.x, cvs.height); ctx.moveTo(0, s.y); ctx.lineTo(cvs.width, s.y); ctx.stroke(); ctx.setLineDash([]);
       ctx.beginPath(); ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2;
       const size = 10;
       ctx.moveTo(s.x - size, s.y - size/2); ctx.lineTo(s.x - size, s.y - size); ctx.lineTo(s.x - size/2, s.y - size);
       ctx.moveTo(s.x + size/2, s.y - size); ctx.lineTo(s.x + size, s.y - size); ctx.lineTo(s.x + size, s.y - size/2);
       ctx.moveTo(s.x + size, s.y + size/2); ctx.lineTo(s.x + size, s.y + size); ctx.lineTo(s.x + size/2, s.y + size);
       ctx.moveTo(s.x - size/2, s.y + size); ctx.lineTo(s.x - size, s.y + size); ctx.lineTo(s.x - size, s.y + size/2);
       ctx.moveTo(s.x - 4, s.y); ctx.lineTo(s.x + 4, s.y); ctx.moveTo(s.x, s.y - 4); ctx.lineTo(s.x, s.y + 4); ctx.stroke();
    }
    
    if (mode === 'DRAW' && drawingStartNodeRef.current && tempWallEnd) {
        const startNode = nodes.find(n => n.id === drawingStartNodeRef.current) || startNodePreview;
        if (startNode) {
             const s1 = toScreen(startNode.x, startNode.y); const s2 = toScreen(tempWallEnd.x, tempWallEnd.y);
             const dx = s2.x - s1.x; const dy = s2.y - s1.y; const len = Math.hypot(dx, dy);
             if (len > 5) {
                 const nx = -dy / len; const ny = dx / len; const worldLen = len / zoom;
                 drawDimension(ctx, s1, s2, nx, ny, 25, worldLen, 'CENTER', true);
             }
        }
    }

    if (activeObjRef.current === 'RECT' && tempRectEnd) {
        const startPos = toWorld(dragStartRef.current.x, dragStartRef.current.y); const endPos = tempRectEnd;
        const s1 = toScreen(startPos.x, startPos.y); const s2 = toScreen(endPos.x, startPos.y); const s3 = toScreen(endPos.x, endPos.y); const s4 = toScreen(startPos.x, endPos.y);
        ctx.beginPath(); ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
        ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.lineTo(s3.x, s3.y); ctx.lineTo(s4.x, s4.y); ctx.closePath(); ctx.stroke(); ctx.setLineDash([]);
        const width = Math.abs(endPos.x - startPos.x); const height = Math.abs(endPos.y - startPos.y);
        drawDimension(ctx, s1, s2, 0, -1, 20, width, 'CENTER', true); drawDimension(ctx, s2, s3, 1, 0, 20, height, 'CENTER', true);
    }
    
    if (mode === 'ROTATE' && nodes.length > 0) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        nodes.forEach(n => { if(n.x < minX) minX = n.x; if(n.x > maxX) maxX = n.x; if(n.y < minY) minY = n.y; if(n.y > maxY) maxY = n.y; });
        const cx = (minX + maxX) / 2; const cy = (minY + maxY) / 2; const sCenter = toScreen(cx, cy);
        ctx.beginPath(); ctx.fillStyle = '#2563eb'; ctx.arc(sCenter.x, sCenter.y, 5, 0, Math.PI*2); ctx.fill();
        if (isDraggingRef.current) {
             ctx.beginPath(); ctx.strokeStyle = '#2563eb'; ctx.setLineDash([5, 5]); ctx.moveTo(sCenter.x, sCenter.y);
             ctx.lineTo(dragStartRef.current.x, dragStartRef.current.y); ctx.stroke(); ctx.setLineDash([]);
        }
    }

  }, [nodes, walls, objects, furniture, viewport, selectedId, tempWallEnd, startNodePreview, cursorPos, mode, tempRectEnd]);

  const drawDimension = (ctx: CanvasRenderingContext2D, p1: Point, p2: Point, nx: number, ny: number, offset: number, val: number, type: 'INNER'|'OUTER'|'CENTER', isActive: boolean) => {
     const gap = 10;
     const extStart1 = { x: p1.x + nx * gap, y: p1.y + ny * gap }; const extStart2 = { x: p2.x + nx * gap, y: p2.y + ny * gap };
     const extEnd1 = { x: p1.x + nx * (offset + 5), y: p1.y + ny * (offset + 5) }; const extEnd2 = { x: p2.x + nx * (offset + 5), y: p2.y + ny * (offset + 5) };
     const dimP1 = { x: p1.x + nx * offset, y: p1.y + ny * offset }; const dimP2 = { x: p2.x + nx * offset, y: p2.y + ny * offset };
     ctx.beginPath(); ctx.strokeStyle = isActive ? COLORS.dimLineActive : COLORS.dimLineInactive; ctx.lineWidth = isActive ? 2 : 1; 
     ctx.moveTo(dimP1.x, dimP1.y); ctx.lineTo(dimP2.x, dimP2.y); 
     if (type !== 'CENTER') { ctx.moveTo(extStart1.x, extStart1.y); ctx.lineTo(extEnd1.x, extEnd1.y); ctx.moveTo(extStart2.x, extStart2.y); ctx.lineTo(extEnd2.x, extEnd2.y); }
     ctx.stroke();
     const tickSize = 4; const slx = -ny; const sly = nx; const slashDx = (slx + nx) * tickSize; const slashDy = (sly + ny) * tickSize;
     ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = isActive ? COLORS.dimLineActive : COLORS.dimLineInactive; 
     ctx.moveTo(dimP1.x - slashDx, dimP1.y - slashDy); ctx.lineTo(dimP1.x + slashDx, dimP1.y + slashDy);
     ctx.moveTo(dimP2.x - slashDx, dimP2.y - slashDy); ctx.lineTo(dimP2.x + slashDx, dimP2.y + slashDy); ctx.stroke();
     const mid = { x: (dimP1.x+dimP2.x)/2, y: (dimP1.y+dimP2.y)/2 }; 
     ctx.save(); ctx.translate(mid.x, mid.y);
     const angle = Math.atan2(dimP2.y - dimP1.y, dimP2.x - dimP1.x); 
     ctx.rotate((angle > Math.PI/2 || angle < -Math.PI/2) ? angle + Math.PI : angle);
     const text = `${(val/100).toFixed(2)}m`; const textMetrics = ctx.measureText(text); const bgWidth = textMetrics.width + 16; const bgHeight = 20;
     ctx.beginPath(); ctx.roundRect(-bgWidth/2, -bgHeight/2, bgWidth, bgHeight, 4); ctx.fillStyle = 'white'; ctx.fill();
     ctx.lineWidth = isActive ? 2 : 1; ctx.strokeStyle = isActive ? COLORS.dimLineActive : '#e2e8f0'; ctx.stroke();
     ctx.fillStyle = isActive ? COLORS.dimLineActive : COLORS.dimText; ctx.font = isActive ? 'bold 14px sans-serif' : '12px sans-serif';
     ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, 0, 0); ctx.restore();
  };

  useEffect(() => { 
      let frame = requestAnimationFrame(function loop() { 
          draw(); 
          if (snapshotPendingRef.current && canvasRef.current) {
              try {
                  const data = canvasRef.current.toDataURL(); setPlanSnapshot(data); setShowReport(true);
              } catch (e) { console.error("Snapshot failed", e); }
              snapshotPendingRef.current = false; isExportingRef.current = false;
          }
          frame = requestAnimationFrame(loop); 
      }); 
      return () => cancelAnimationFrame(frame); 
  }, [draw]);
  
  useEffect(() => {
      const handleResize = () => { if(containerRef.current && canvasRef.current) { canvasRef.current.width = containerRef.current.clientWidth; canvasRef.current.height = containerRef.current.clientHeight; draw(); } };
      window.addEventListener('resize', handleResize); handleResize(); return () => window.removeEventListener('resize', handleResize);
  }, [draw]);

  const deleteSelected = () => {
    if (!selectedId) return;
    if (selectedId.type === 'WALL') { setWalls(walls.filter(w => w.id !== selectedId.id)); setObjects(objects.filter(o => o.wallId !== selectedId.id)); } 
    else if (selectedId.type === 'OBJECT') { setObjects(objects.filter(o => o.id !== selectedId.id)); }
    else if (selectedId.type === 'FURNITURE') { setFurniture(furniture.filter(f => f.id !== selectedId.id)); }
    setSelectedId(null); setContextMenuPos(null); setShowProps(false); saveHistory();
  };

  const getDisplayLength = (wallId: string) => {
      const w = walls.find(wa => wa.id === wallId); if (!w) return 0;
      const n1 = nodes.find(n => n.id === w.startNodeId); const n2 = nodes.find(n => n.id === w.endNodeId); if (!n1 || !n2) return 0;
      const centerLen = Math.hypot(n2.x - n1.x, n2.y - n1.y);
      if (measureMode === 'OUTER') return centerLen + w.thickness; if (measureMode === 'INNER') return Math.max(0, centerLen - w.thickness); return centerLen;
  };

  const updateProp = (key: string, val: number) => {
    if (!selectedId) return;
    if (selectedId.type === 'WALL') {
        if (key === 'length') {
            if (val > 800) val = 800;
            const w = walls.find(wa => wa.id === selectedId.id);
            if (w) {
                const n1 = nodes.find(n => n.id === w.startNodeId); const n2 = nodes.find(n => n.id === w.endNodeId);
                if (n1 && n2) {
                    let targetCenterLen = val; if (measureMode === 'OUTER') targetCenterLen = val - w.thickness; if (measureMode === 'INNER') targetCenterLen = val + w.thickness;
                    const currentLen = Math.hypot(n2.x - n1.x, n2.y - n1.y);
                    if (currentLen > 0) { const ratio = targetCenterLen / currentLen; const newX = n1.x + (n2.x - n1.x) * ratio; const newY = n1.y + (n2.y - n1.y) * ratio; setNodes(prev => prev.map(n => n.id === n2.id ? { ...n, x: newX, y: newY } : n)); }
                }
            }
        } else { setWalls(walls.map(w => w.id === selectedId.id ? {...w, [key]: val} : w)); }
    }
    if (selectedId.type === 'OBJECT') setObjects(objects.map(o => o.id === selectedId.id ? {...o, [key]: val} : o));
    saveHistory();
  };
  const toggleFlip = (axis: 'X' | 'Y') => { 
      if (selectedId?.type === 'OBJECT') { setObjects(objects.map(o => o.id === selectedId.id ? {...o, [axis === 'X' ? 'flipX' : 'flipY']: !o[axis === 'X' ? 'flipX' : 'flipY']} : o)); saveHistory(); } 
      if (selectedId?.type === 'FURNITURE') { setFurniture(furniture.map(f => f.id === selectedId.id ? {...f, rotation: f.rotation + Math.PI/2} : f)); saveHistory(); }
  };
  const getSelectedWallLength = () => { if (selectedId?.type === 'WALL') return getDisplayLength(selectedId.id); return 0; };
  const getRotationHandlePos = () => null;

  const handleSavePDF = async () => {
      const element = document.getElementById('print-template');
      if(!element) return;
      const btn = document.getElementById('save-pdf-btn');
      if(btn) { btn.innerText = "جاري المعالجة..."; btn.style.opacity = '0.7'; btn.style.pointerEvents = 'none'; }
      try {
          const canvas = await html2canvas(element, { scale: 2, useCORS: true, allowTaint: true, backgroundColor: '#ffffff', logging: false, windowWidth: 794, height: element.scrollHeight, windowHeight: element.scrollHeight,
              onclone: (clonedDoc) => {
                  const links = clonedDoc.querySelectorAll('link[rel="stylesheet"]'); links.forEach(l => l.remove());
                  const styles = clonedDoc.querySelectorAll('style'); styles.forEach(s => s.remove());
                  const allElements = clonedDoc.querySelectorAll('*'); allElements.forEach((el: any) => { const inlineStyle = el.getAttribute('style'); if (inlineStyle && inlineStyle.includes('oklch')) { el.setAttribute('style', inlineStyle.replace(/oklch\([^)]+\)/gi, '#000000')); } });
              }
          });
          const imgData = canvas.toDataURL('image/jpeg', 0.95);
          const pdf = new jsPDF('p', 'mm', 'a4');
          const pdfWidth = pdf.internal.pageSize.getWidth(); const pdfHeight = pdf.internal.pageSize.getHeight();
          const imgWidth = canvas.width; const imgHeight = canvas.height; const ratio = pdfWidth / imgWidth; const scaledHeight = imgHeight * ratio;
          
          if (scaledHeight <= pdfHeight) { pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, scaledHeight); } else { let heightLeft = scaledHeight; let page = 1; pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, scaledHeight); heightLeft -= pdfHeight; while (heightLeft > 0) { pdf.addPage(); pdf.addImage(imgData, 'JPEG', 0, -(pdfHeight * page), pdfWidth, scaledHeight); heightLeft -= pdfHeight; page++; } }
          pdf.save(`${reportData.clientName || 'Report'}.pdf`);
      } catch (err) { console.error("PDF Error:", err); alert("حدث خطأ أثناء الحفظ"); } finally { if(btn) { btn.innerText = "حفظ الملف (PDF)"; btn.style.opacity = '1'; btn.style.pointerEvents = 'auto'; } }
  };

  if (showReport) {
    const stats = calculateStats();
    const reportDate = new Date();
    const reportID = `RP-${reportDate.getFullYear()}${(reportDate.getMonth()+1).toString().padStart(2,'0')}-${reportDate.getDate().toString().padStart(2,'0')}-${reportDate.getHours()}${reportDate.getMinutes()}`;
    
    return (
      <div className="fixed inset-0 z-[60] overflow-auto font-sans" dir="rtl" style={{backgroundColor: '#ffffff'}}>
         <button onClick={() => setShowReport(false)} className="fixed top-4 left-4 p-2 bg-black text-white rounded-full shadow-lg z-50 no-print"><X className="w-6 h-6" /></button>
         <button id="save-pdf-btn" onClick={handleSavePDF} className="fixed top-4 left-16 p-2 px-4 rounded-full shadow-lg z-50 no-print hover:bg-blue-700 flex items-center gap-2 font-bold" style={{backgroundColor: '#2563eb', color: '#ffffff'}}><Save className="w-5 h-5" /><span>حفظ الملف (PDF)</span></button>

         <div id="report-content" className="w-[210mm] mx-auto min-h-screen p-8 my-8 bg-white shadow-sm" style={{backgroundColor: '#ffffff', border: '1px solid #e5e7eb', boxSizing: 'border-box'}}>
             <div className="pb-6 mb-8" style={{borderBottom: '4px solid #2563eb'}}>
                <div className="flex justify-between items-start">
                   <div><h1 className="text-3xl font-black mb-2" style={{color: '#111827'}}>{t.reportTitle}</h1><div className="flex items-center gap-2 font-mono text-sm" style={{color: '#6b7280'}}><span className="font-bold">ID:</span><span className="px-2 py-0.5 rounded" style={{backgroundColor: '#f3f4f6'}}>{reportID}</span></div><p className="text-xs mt-1" style={{color: '#9ca3af'}}>{reportDate.toLocaleDateString('en-GB')} {reportDate.toLocaleTimeString('en-US', {hour: '2-digit', minute:'2-digit'})}</p></div>
                   <div className="text-left"><h2 className="text-xl font-bold" style={{color: '#1e40af'}}>Room Planner Pro</h2><p className="text-xs" style={{color: '#9ca3af'}}>{t.reportSub}</p></div>
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 mt-6 p-4 rounded-xl" style={{backgroundColor: '#f9fafb', border: '1px solid #f3f4f6'}}>
                   <div><label className="block text-xs mb-1" style={{color: '#9ca3af'}}>{t.client}</label><input type="text" className="w-full bg-transparent font-bold focus:outline-none transition-colors placeholder-[#9ca3af]" style={{borderBottom: '1px solid #d1d5db', color: '#111827'}} placeholder="أدخل اسم العميل" value={reportData.clientName} onChange={(e) => setReportData({...reportData, clientName: e.target.value})} /></div>
                   <div><label className="block text-xs mb-1" style={{color: '#9ca3af'}}>{t.contractor}</label><input type="text" className="w-full bg-transparent font-bold focus:outline-none transition-colors placeholder-[#9ca3af]" style={{borderBottom: '1px solid #d1d5db', color: '#111827'}} placeholder="أدخل اسم المقاول" value={reportData.contractorName} onChange={(e) => setReportData({...reportData, contractorName: e.target.value})} /></div>
                </div>
                <div className="flex gap-2 mt-4 no-print">
                  <button onClick={() => setReportFilter('GENERAL')} className={`px-4 py-2 rounded-full text-sm font-bold transition-colors`} style={{backgroundColor: reportFilter === 'GENERAL' ? '#2563eb' : '#f3f4f6', color: reportFilter === 'GENERAL' ? '#ffffff' : '#4b5563'}}>{t.gen}</button>
                  <button onClick={() => setReportFilter('PAINT')} className={`px-4 py-2 rounded-full text-sm font-bold transition-colors`} style={{backgroundColor: reportFilter === 'PAINT' ? '#2563eb' : '#f3f4f6', color: reportFilter === 'PAINT' ? '#ffffff' : '#4b5563'}}>{t.paint}</button>
                  <button onClick={() => setReportFilter('FLOOR')} className={`px-4 py-2 rounded-full text-sm font-bold transition-colors`} style={{backgroundColor: reportFilter === 'FLOOR' ? '#2563eb' : '#f3f4f6', color: reportFilter === 'FLOOR' ? '#ffffff' : '#4b5563'}}>{t.floor}</button>
                </div>
             </div>
            
            <div className="mb-8 rounded-xl p-2 h-[400px] flex items-center justify-center relative overflow-hidden" style={{backgroundColor: '#ffffff', border: '1px solid #e5e7eb'}}>
               {planSnapshot ? <img src={planSnapshot} className="w-full h-full object-contain" alt="Plan" /> : <p style={{color: '#9ca3af'}}>{t.loading}</p>}
            </div>

             <div className="mb-8 break-inside-avoid">
               <h3 className="text-lg font-bold pr-3 mb-4 flex items-center gap-2" style={{borderRight: '4px solid #2563eb'}}>
                   <Calculator className="w-5 h-5" style={{color: '#2563eb'}} />
                   {reportFilter === 'GENERAL' ? t.summary : reportFilter === 'PAINT' ? t.summaryPaint : t.summaryFloor}
               </h3>
               <table className="w-full border-collapse text-sm rounded-xl overflow-hidden" style={{border: '1px solid #e5e7eb'}}>
                  <thead><tr style={{backgroundColor: '#f3f4f6', color: '#374151', borderBottom: '1px solid #e5e7eb'}}><th className="p-3 text-right">{t.item}</th><th className="p-3 text-center">{t.unit}</th><th className="p-3 text-center">{t.qty}</th><th className="p-3 text-right">{t.notes}</th></tr></thead>
                  <tbody style={{borderColor: '#f3f4f6'}}>
                     {(reportFilter === 'GENERAL' || reportFilter === 'FLOOR') && (<><tr style={{borderBottom: '1px solid #f3f4f6'}}><td className="p-3 font-bold" style={{color: '#1e3a8a'}}>{t.floorArea}</td><td className="p-3 text-center" style={{backgroundColor: '#f9fafb'}}>م²</td><td className="p-3 text-center font-black text-lg">{stats.floorAreaM2}</td><td className="p-3 text-xs" style={{color: '#6b7280'}}>صافي المساحة الداخلية</td></tr><tr style={{borderBottom: '1px solid #f3f4f6'}}><td className="p-3 font-medium">{t.skirting}</td><td className="p-3 text-center" style={{backgroundColor: '#f9fafb'}}>م.ط</td><td className="p-3 text-center font-bold">{stats.wallLengthM}</td><td className="p-3 text-xs" style={{color: '#6b7280'}}>محيط الغرفة</td></tr></>)}
                     {(reportFilter === 'GENERAL' || reportFilter === 'PAINT') && (<><tr style={{borderBottom: '1px solid #f3f4f6'}}><td className="p-3 font-bold" style={{color: '#1e3a8a'}}>{t.paintWall}</td><td className="p-3 text-center" style={{backgroundColor: '#f9fafb'}}>م²</td><td className="p-3 text-center font-black text-lg">{stats.netPaintAreaM2}</td><td className="p-3 text-xs" style={{color: '#6b7280'}}>بدون فتحات</td></tr><tr style={{borderBottom: '1px solid #f3f4f6'}}><td className="p-3 font-medium">{t.paintCeiling}</td><td className="p-3 text-center" style={{backgroundColor: '#f9fafb'}}>م²</td><td className="p-3 text-center font-bold">{stats.ceilingAreaM2}</td><td className="p-3 text-xs" style={{color: '#6b7280'}}>مساحة السقف</td></tr></>)}
                     {reportFilter === 'GENERAL' && (<><tr style={{backgroundColor: 'rgba(249, 250, 251, 0.5)', borderBottom: '1px solid #f3f4f6'}}><td className="p-3 font-medium">{t.doorCount}</td><td className="p-3 text-center" style={{backgroundColor: '#f9fafb'}}>عدد</td><td className="p-3 text-center font-bold">{stats.doorCount}</td><td className="p-3 text-xs" style={{color: '#6b7280'}}>-</td></tr><tr style={{backgroundColor: 'rgba(249, 250, 251, 0.5)', borderBottom: '1px solid #f3f4f6'}}><td className="p-3 font-medium">{t.windowCount}</td><td className="p-3 text-center" style={{backgroundColor: '#f9fafb'}}>عدد</td><td className="p-3 text-center font-bold">{stats.windowCount}</td><td className="p-3 text-xs" style={{color: '#6b7280'}}>-</td></tr></>)}
                     {reportFilter === 'GENERAL' && (<tr style={{backgroundColor: 'rgba(249, 250, 251, 0.5)', borderBottom: '1px solid #f3f4f6'}}><td className="p-3 font-medium">{t.furnitureCount}</td><td className="p-3 text-center" style={{backgroundColor: '#f9fafb'}}>عدد</td><td className="p-3 text-center font-bold">{stats.furnitureCount}</td><td className="p-3 text-xs" style={{color: '#6b7280'}}>قطع</td></tr>)}
                  </tbody>
               </table>
            </div>

            <div className="pt-8 mt-12 flex flex-col gap-6" style={{borderTop: '2px solid #f3f4f6'}}>
                <div className="flex justify-between items-end text-sm" style={{color: '#6b7280'}}>
                    <div className="text-center"><p className="mb-4 font-bold">{t.sign}</p><div className="w-40" style={{borderBottom: '1px dashed #d1d5db'}}></div></div>
                    <div className="text-center"><p className="mb-4 font-bold">{t.stamp}</p><div className="w-40" style={{borderBottom: '1px dashed #d1d5db'}}></div></div>
                </div>
                <div className="rounded-xl p-4 text-center mt-4" style={{backgroundColor: '#f9fafb'}}>
                    <p className="font-bold text-sm md:text-base" style={{color: '#1e3a8a'}}>تم إنشاء هذا التقرير تلقائيا بواسطة بيت الريف منصتك الذكية دائما وياك</p>
                    <p className="text-[10px] mt-1 font-mono" style={{color: '#9ca3af'}}>Generated by Biet Alreef Smart Platform</p>
                </div>
            </div>
         </div>
       {/* Print Template Hidden */}
       <div id="print-template" style={{ position: 'absolute', top: 0, left: '-9999px', width: '210mm', minHeight: '297mm', backgroundColor: 'white', padding: '10mm', direction: 'rtl', zIndex: -10, fontFamily: 'system-ui, -apple-system, sans-serif' }}>
            <div className="print-content-wrapper">
                  <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px', borderBottom: '2px solid #2563eb', paddingBottom: '10px'}}>
                      <div><h1 style={{fontSize: '24px', fontWeight: '900', color: '#111827', marginBottom: '4px'}}>{t.reportTitle}</h1><p style={{fontSize: '12px', color: '#6b7280'}}>{t.reportSub}</p></div>
                      <div style={{textAlign: 'left'}}><div style={{fontSize: '14px', fontWeight: 'bold', color: '#111827'}}>ID: {reportID}</div><div style={{fontSize: '12px', color: '#6b7280'}}>{reportDate.toLocaleDateString('en-GB')}</div></div>
                  </div>
                  <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', marginBottom: '20px', backgroundColor: '#f9fafb', padding: '15px', borderRadius: '8px', border: '1px solid #e5e7eb'}}>
                      <div><label style={{fontSize: '10px', color: '#6b7280', display: 'block', marginBottom: '4px'}}>{t.client}</label><div style={{fontWeight: 'bold', fontSize: '14px', color: '#111827'}}>{reportData.clientName || '-'}</div></div>
                      <div><label style={{fontSize: '10px', color: '#6b7280', display: 'block', marginBottom: '4px'}}>{t.contractor}</label><div style={{fontWeight: 'bold', fontSize: '14px', color: '#111827'}}>{reportData.contractorName || '-'}</div></div>
                  </div>
                  <div style={{marginBottom: '20px', height: '300px', border: '1px solid #e5e7eb', borderRadius: '8px', display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden', backgroundColor: '#fff'}}>
                      {planSnapshot ? <img src={planSnapshot} style={{maxHeight: '100%', maxWidth: '100%', objectFit: 'contain'}} /> : null}
                  </div>
                  <div style={{display: 'flex', gap: '20px', alignItems: 'flex-start'}}>
                      <div style={{flex: 1}}>
                          <h3 style={{fontSize: '14px', fontWeight: 'bold', marginBottom: '8px', color: '#111827'}}>{t.summary}</h3>
                          <table style={{width: '100%', borderCollapse: 'collapse', fontSize: '12px'}}>
                              <thead><tr style={{backgroundColor: '#f3f4f6', borderBottom: '1px solid #e5e7eb', color: '#374151'}}><th style={{padding: '6px', textAlign: 'right'}}>{t.item}</th><th style={{padding: '6px', textAlign: 'center'}}>{t.qty}</th></tr></thead>
                              <tbody>
                                  <tr><td style={{padding: '6px', borderBottom: '1px solid #f3f4f6'}}>المساحة الاجمالية</td><td style={{padding: '6px', textAlign: 'center', fontWeight: 'bold', dir: 'ltr'}}>{stats.floorAreaM2} m²</td></tr>
                                  <tr><td style={{padding: '6px', borderBottom: '1px solid #f3f4f6'}}>مساحة الحوائط</td><td style={{padding: '6px', textAlign: 'center', fontWeight: 'bold', dir: 'ltr'}}>{stats.netPaintAreaM2} m²</td></tr>
                                  <tr><td style={{padding: '6px', borderBottom: '1px solid #f3f4f6'}}>قطع الأثاث</td><td style={{padding: '6px', textAlign: 'center', fontWeight: 'bold'}}>{stats.furnitureCount}</td></tr>
                              </tbody>
                          </table>
                      </div>
                  </div>
                  <div style={{marginTop: '30px', paddingTop: '10px', borderTop: '1px dashed #e5e7eb', textAlign: 'center', fontSize: '10px', color: '#9ca3af'}}>
                      <p style={{marginBottom: '4px'}}>تم إنشاء هذا التقرير بواسطة منصة بيت الريف الذكية</p>
                      <p style={{fontFamily: 'monospace'}}>Generated by Biet Alreef Smart Platform</p>
                  </div>
              </div>
       </div>

     </div>
    );
  }

  return (
    <div className="fixed inset-0 bg-[#ffffff] z-50 flex flex-col select-none" dir="rtl">
      <div className="h-14 bg-white shadow-sm flex items-center justify-between px-4 z-20 border-b border-gray-100">
        <div className="flex items-center gap-2">
           <button onClick={onBack} className="p-2 rounded-full hover:bg-blue-50"><ArrowRight className="w-5 h-5 text-blue-600"/></button>
           <span className="font-bold text-gray-800 text-sm">{t.title}</span>
        </div>
        <div className="flex gap-2">
           <button onClick={() => setShowHelp(true)} className="p-2 rounded-full hover:bg-gray-100 text-gray-600 border border-gray-200"><HelpCircle className="w-5 h-5"/></button>
           <button onClick={() => setLang(l => l === 'AR' ? 'EN' : 'AR')} className="p-2 rounded-full hover:bg-gray-100 text-gray-600 border border-gray-200"><Globe className="w-5 h-5"/></button>
           <button onClick={undo} className="p-2 rounded-full hover:bg-gray-100 text-gray-600"><Undo2 className="w-5 h-5"/></button>
           <button onClick={() => setShow3D(true)} className="p-2 rounded-full hover:bg-blue-50 text-blue-600 border border-blue-200" title="عرض ثلاثي الأبعاد"><Grid3X3 className="w-5 h-5"/></button>
           <button onClick={openReport} className="p-2 rounded-full hover:bg-blue-50 text-blue-600" title="تقرير هندسي"><FileText className="w-5 h-5"/></button>
           <button onClick={() => setShowSaveMenu(true)} className="p-2 rounded-full hover:bg-gray-100 text-gray-600"><Save className="w-5 h-5"/></button>
        </div>
      </div>

      <div ref={containerRef} className="flex-1 relative overflow-hidden cursor-crosshair bg-white">
        <canvas
          ref={canvasRef}
          width={window.innerWidth}
          height={window.innerHeight}
          className="touch-none block"
          onMouseDown={handlePointerDown} onMouseMove={handlePointerMove} onMouseUp={handlePointerUp}
          onTouchStart={handlePointerDown} onTouchMove={handlePointerMove} onTouchEnd={handlePointerUp}
        />
        
        <div className="absolute bottom-32 left-4 flex flex-col gap-2">
          <button onClick={() => setViewport(v => ({...v, zoom: v.zoom * 1.1}))} className="bg-white p-2.5 rounded-full shadow-md text-gray-600 border border-gray-200"><ZoomIn className="w-5 h-5"/></button>
          <button onClick={() => setViewport(v => ({...v, zoom: v.zoom / 1.1}))} className="bg-white p-2.5 rounded-full shadow-md text-gray-600 border border-gray-200"><ZoomOut className="w-5 h-5"/></button>
        </div>
        
        {showProps && selectedId && (
          <div className="fixed bottom-28 left-4 right-4 md:w-auto md:left-1/2 md:-translate-x-1/2 bg-white rounded-2xl shadow-2xl border border-gray-100 p-2 z-[60] animate-in slide-in-from-bottom-5 fade-in duration-300">
            <div className="flex items-center gap-2 overflow-x-auto no-scrollbar px-1">
                <button onClick={() => setShowProps(false)} className="flex-shrink-0 w-7 h-7 bg-gray-100 rounded-full flex items-center justify-center text-gray-500 hover:bg-red-50 hover:text-red-500"><X className="w-4 h-4"/></button>
                <div className="w-[1px] h-6 bg-gray-200 mx-1 flex-shrink-0"></div>

                {selectedId.type === 'WALL' && (
                    <>
                        <div className="flex items-center gap-1 bg-gray-50 rounded-lg p-1 flex-shrink-0">
                             <div className="flex flex-col items-center mx-1">
                                <span className="text-[8px] text-gray-400 font-bold leading-none mb-0.5">وضع القياس</span>
                                <div className="relative bg-white rounded shadow-sm border border-gray-200 flex items-center pr-1 pl-2 h-6">
                                    {measureMode === 'INNER' ? <Minimize2 className="w-3 h-3 text-blue-600 ml-1"/> : measureMode === 'OUTER' ? <Maximize2 className="w-3 h-3 text-blue-600 ml-1"/> : <AlignCenter className="w-3 h-3 text-blue-600 ml-1"/>}
                                    <select value={measureMode} onChange={(e) => setMeasureMode(e.target.value as any)} className="text-[10px] font-bold text-gray-700 bg-transparent outline-none appearance-none w-16" dir="rtl">
                                        <option value="INNER">من الداخل</option><option value="CENTER">من المنتصف</option><option value="OUTER">من الخارج</option>
                                    </select>
                                    <ChevronDown className="w-3 h-3 text-gray-400 absolute left-0.5 pointer-events-none"/>
                                </div>
                             </div>
                             <div className="w-[1px] h-6 bg-gray-200 mx-1 flex-shrink-0"></div>
                             <div className="flex flex-col items-center w-14">
                                <span className="text-[8px] text-gray-400 font-bold leading-none mb-0.5">الطول</span>
                                <input type="number" className="w-full bg-transparent text-center text-xs font-black text-gray-700 outline-none p-0 border-none h-4" value={getSelectedWallLength().toFixed(0)} onChange={(e) => updateProp('length', Number(e.target.value))} />
                             </div>
                        </div>
                        <div className="flex flex-col items-center w-10 bg-gray-50 rounded-lg p-1 flex-shrink-0"><span className="text-[8px] text-gray-400 font-bold leading-none mb-0.5">سمك</span><input type="number" className="w-full bg-transparent text-center text-xs font-bold text-gray-600 outline-none p-0 border-none h-4" value={walls.find(w => w.id === selectedId.id)?.thickness || 20} onChange={(e) => updateProp('thickness', Number(e.target.value))} /></div>
                        <div className="w-[1px] h-6 bg-gray-200 mx-1 flex-shrink-0"></div>
                        <button onClick={() => { const w = walls.find(wa => wa.id === selectedId.id); if(w) { setObjects([...objects, { id: Math.random().toString(), wallId: w.id, type: 'DOOR', t: 0.5, width: 90, height: 210, leafCount: 1 }]); saveHistory(); } }} className="flex-shrink-0 p-2 hover:bg-blue-50 text-blue-600 rounded-xl flex flex-col items-center gap-0.5" title="باب مفرد"><DoorOpen className="w-5 h-5"/><span className="text-[8px] font-bold">مفرد</span></button>
                        <button onClick={() => { const w = walls.find(wa => wa.id === selectedId.id); if(w) { setObjects([...objects, { id: Math.random().toString(), wallId: w.id, type: 'DOOR', t: 0.5, width: 160, height: 210, leafCount: 2 }]); saveHistory(); } }} className="flex-shrink-0 p-2 hover:bg-blue-50 text-blue-600 rounded-xl flex flex-col items-center gap-0.5" title="باب مزدوج"><div className="relative"><DoorOpen className="w-5 h-5"/><span className="absolute -top-1 -right-1 bg-blue-600 text-white text-[8px] w-3 h-3 rounded-full flex items-center justify-center">2</span></div><span className="text-[8px] font-bold">مزدوج</span></button>
                        <button onClick={() => { const w = walls.find(wa => wa.id === selectedId.id); if(w) { setObjects([...objects, { id: Math.random().toString(), wallId: w.id, type: 'WINDOW', t: 0.5, width: 100, height: 120, sillHeight: 150 }]); saveHistory(); } }} className="flex-shrink-0 p-2 hover:bg-blue-50 text-blue-600 rounded-xl flex flex-col items-center gap-0.5"><Grid3X3 className="w-5 h-5"/></button>
                        <div className="w-[1px] h-6 bg-gray-200 mx-1 flex-shrink-0"></div>
                        <button onClick={() => { const w = walls.find(wa => wa.id === selectedId.id); if(w) { setMode('DRAW'); drawingStartNodeRef.current = w.endNodeId; setStartNodePreview(nodes.find(n => n.id === w.endNodeId) || null); setShowProps(false); } }} className="flex-shrink-0 p-2 bg-blue-50 hover:bg-blue-100 text-blue-600 rounded-xl flex flex-col items-center gap-0.5" title="إضافة جدار"><Plus className="w-5 h-5"/><span className="text-[8px] font-bold">إضافة</span></button>
                    </>
                )}

                {selectedId.type === 'OBJECT' && (
                    <>
                        <div className="flex items-center gap-1 bg-gray-50 rounded-lg p-1 flex-shrink-0">
                             <div className="flex flex-col items-center w-12 border-r border-gray-200 pr-1"><span className="text-[8px] text-gray-400 font-bold leading-none mb-0.5">عرض</span><input type="number" className="w-full bg-transparent text-center text-xs font-black text-gray-700 outline-none p-0 border-none h-4" value={objects.find(o => o.id === selectedId.id)?.width || 90} onChange={(e) => updateProp('width', Number(e.target.value))} /></div>
                             <div className="flex flex-col items-center w-12 pl-1"><span className="text-[8px] text-gray-400 font-bold leading-none mb-0.5">ارتفاع</span><input type="number" className="w-full bg-transparent text-center text-xs font-black text-gray-700 outline-none p-0 border-none h-4" value={objects.find(o => o.id === selectedId.id)?.height || 210} onChange={(e) => updateProp('height', Number(e.target.value))} /></div>
                        </div>
                         {(() => { const obj = objects.find(o => o.id === selectedId.id); if (obj?.type === 'WINDOW') return (<div className="flex flex-col items-center w-12 bg-gray-50 rounded-lg p-1 flex-shrink-0 ml-1"><span className="text-[8px] text-gray-400 font-bold leading-none mb-0.5">جلسة</span><input type="number" className="w-full bg-transparent text-center text-xs font-bold text-blue-600 outline-none p-0 border-none h-4" value={obj.sillHeight || 150} onChange={(e) => updateProp('sillHeight', Number(e.target.value))} /></div>); if (obj?.type === 'DOOR') return (<div className="flex items-center bg-gray-100 rounded-lg p-1 h-8 ml-1"><button onClick={() => updateProp('leafCount', 1)} className={`px-3 h-full rounded-md text-xs font-bold transition-all ${obj.leafCount !== 2 ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-400 hover:text-gray-600'}`}>مفرد</button><button onClick={() => updateProp('leafCount', 2)} className={`px-3 h-full rounded-md text-xs font-bold transition-all ${obj.leafCount === 2 ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-400 hover:text-gray-600'}`}>مزدوج</button></div>); return null; })()}
                        <div className="w-[1px] h-6 bg-gray-200 mx-1 flex-shrink-0"></div>
                        <button onClick={() => toggleFlip('X')} className="flex-shrink-0 p-2 hover:bg-blue-50 text-gray-600 rounded-lg" title="عكس اتجاه"><ArrowRightLeft className="w-4 h-4"/></button>
                        <button onClick={() => toggleFlip('Y')} className="flex-shrink-0 p-2 hover:bg-blue-50 text-gray-600 rounded-lg" title="عكس فتح"><ArrowUpDown className="w-4 h-4"/></button>
                    </>
                )}

                {selectedId.type === 'FURNITURE' && (
                    <>
                        <div className="flex items-center gap-2">
                             <span className="text-xs font-bold text-gray-700">{FURNITURE_TEMPLATES[furniture.find(f => f.id === selectedId.id)?.type as FurnitureType]?.labelAr}</span>
                        </div>
                        <div className="w-[1px] h-6 bg-gray-200 mx-1 flex-shrink-0"></div>
                        <button onClick={() => toggleFlip('Y')} className="flex-shrink-0 p-2 hover:bg-blue-50 text-blue-600 rounded-lg flex flex-col items-center" title="تدوير"><RotateCw className="w-5 h-5"/><span className="text-[8px] font-bold">تدوير</span></button>
                    </>
                )}

                <div className="w-[1px] h-6 bg-gray-200 mx-1 flex-shrink-0"></div>
                <button onClick={deleteSelected} className="flex-shrink-0 p-2 bg-red-50 hover:bg-red-100 text-red-500 rounded-xl"><Trash2 className="w-5 h-5"/></button>
            </div>
          </div>
        )}

      {showHelp && (
        <div className="fixed inset-0 z-[80] bg-black/50 flex items-center justify-center p-4 animate-in fade-in duration-200">
           <div className="bg-white w-full max-w-2xl max-h-[85vh] rounded-2xl shadow-2xl overflow-hidden flex flex-col">
              <div className="p-4 border-b border-gray-100 flex justify-between items-center bg-gray-50"><h2 className="font-black text-lg text-gray-800 flex items-center gap-2"><HelpCircle className="w-5 h-5 text-blue-600"/>دليل الاستخدام</h2><button onClick={() => setShowHelp(false)} className="p-2 hover:bg-gray-200 rounded-full transition-colors"><X className="w-5 h-5 text-gray-500"/></button></div>
              <div className="overflow-y-auto p-6 space-y-8 text-right" dir="rtl">
                 <section><h3 className="text-blue-600 font-bold text-lg mb-4 flex items-center gap-2"><span className="w-6 h-6 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center text-sm">1</span>أدوات الرسم والبناء</h3><div className="bg-gray-50 rounded-xl p-4 space-y-4 border border-gray-100"><div className="flex gap-3"><div className="mt-1"><PenTool className="w-5 h-5 text-gray-700"/></div><div><h4 className="font-bold text-gray-900 mb-1">رسم جدار</h4><p className="text-sm text-gray-600 leading-relaxed">اضغط للبداية، حرك، واضغط للنهاية.</p></div></div><div className="flex gap-3"><div className="mt-1"><Armchair className="w-5 h-5 text-gray-700"/></div><div><h4 className="font-bold text-gray-900 mb-1">إضافة أثاث</h4><p className="text-sm text-gray-600 leading-relaxed">استخدم زر الأثاث لإضافة عناصر وتوزيعها.</p></div></div></div></section>
              </div>
           </div>
        </div>
      )}

      {showSaveMenu && (
         <div className="fixed inset-0 bg-black/50 z-[70] flex items-end justify-center" onClick={() => setShowSaveMenu(false)}>
             <div className="bg-white w-full max-w-md rounded-t-2xl p-6 animate-in slide-in-from-bottom-10 duration-300" onClick={(e) => e.stopPropagation()}>
                 <div className="w-12 h-1.5 bg-gray-200 rounded-full mx-auto mb-6"></div>
                 <h3 className="font-bold text-lg mb-4 text-center">{t.saveOptions}</h3>
                 <div className="space-y-3">
                     <button onClick={handleSaveToFiles} className="w-full flex items-center gap-3 p-4 rounded-xl bg-gray-50 hover:bg-blue-50 transition-colors"><div className="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center text-blue-600"><FolderHeart className="w-5 h-5" /></div><div className="text-right flex-1"><div className="font-bold text-gray-800">{t.saveFile}</div></div><ArrowRight className="w-4 h-4 text-gray-400 rotate-180" /></button>
                     <button onClick={() => { setShowSaveMenu(false); openReport(); }} className="w-full flex items-center gap-3 p-4 rounded-xl bg-gray-50 hover:bg-blue-50 transition-colors"><div className="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center text-blue-600"><FileText className="w-5 h-5" /></div><div className="text-right flex-1"><div className="font-bold text-gray-800">عرض التقرير واستخراج PDF</div></div><ArrowRight className="w-4 h-4 text-gray-400 rotate-180" /></button>
                     <button onClick={handleShare} className="w-full flex items-center gap-3 p-4 rounded-xl bg-gray-50 hover:bg-green-50 transition-colors"><div className="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center text-green-600"><Share2 className="w-5 h-5" /></div><div className="text-right flex-1"><div className="font-bold text-gray-800">{t.shareApp}</div></div><ArrowRight className="w-4 h-4 text-gray-400 rotate-180" /></button>
                     <button onClick={handleSaveImage} className="w-full flex items-center gap-3 p-4 rounded-xl bg-gray-50 hover:bg-purple-50 transition-colors"><div className="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center text-purple-600"><ImageIcon className="w-5 h-5" /></div><div className="text-right flex-1"><div className="font-bold text-gray-800">{t.saveImg}</div></div><ArrowRight className="w-4 h-4 text-gray-400 rotate-180" /></button>
                 </div>
                 <button onClick={() => setShowSaveMenu(false)} className="mt-6 w-full py-3 rounded-xl font-bold text-gray-500 hover:bg-gray-100">إلغاء</button>
             </div>
         </div>
      )}

      {/* NEW: Furniture Sidebar (Left) */}
      {(showFurnitureMenu || window.innerWidth > 768) && (
         <div className="fixed top-24 left-4 z-[40] bg-white rounded-xl shadow-lg border border-gray-100 flex flex-col gap-1 p-1 max-h-[60vh] overflow-y-auto no-scrollbar w-14 animate-in slide-in-from-left-4 duration-300">
             <div className="text-[10px] font-bold text-center text-gray-400 py-1 border-b border-gray-100 mb-1">أثاث</div>
             {Object.entries(FURNITURE_TEMPLATES).map(([type, tmpl]) => {
                 const Icon = tmpl.icon;
                 return (
                     <button key={type} onClick={() => addFurniture(type as FurnitureType)} className="w-12 h-12 flex flex-col items-center justify-center rounded-lg hover:bg-blue-50 text-gray-500 hover:text-blue-600 transition-colors relative group flex-shrink-0">
                         <Icon className="w-5 h-5 mb-0.5" />
                         {/* Tooltip */}
                         <span className="absolute left-full top-1/2 -translate-y-1/2 ml-3 bg-gray-900 text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 whitespace-nowrap pointer-events-none z-50 transition-opacity">
                           {lang === 'AR' ? tmpl.labelAr : tmpl.labelEn}
                         </span>
                     </button>
                 )
             })}
         </div>
      )}

      <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2">
        <div className="bg-white rounded-full shadow-xl border border-gray-100 p-1.5 flex items-center gap-1">
           <button onClick={() => setMode('SELECT')} className={`p-3 rounded-full transition-all ${mode === 'SELECT' ? 'bg-black text-white shadow-md' : 'text-gray-400 hover:bg-gray-50'}`}><MousePointer2 className="w-5 h-5" /></button>
           <div className="w-[1px] h-6 bg-gray-200 mx-1"></div>
           <button onClick={() => setMode('DRAW')} className={`p-3 rounded-full transition-all ${mode === 'DRAW' ? 'bg-blue-600 text-white shadow-md' : 'text-gray-400 hover:bg-gray-50'}`} title="رسم جدار"><PenTool className="w-5 h-5" /></button>
           <div className="w-[1px] h-6 bg-gray-200 mx-1"></div>
           <button onClick={() => setMode('RECT')} className={`p-3 rounded-full transition-all ${mode === 'RECT' ? 'bg-blue-600 text-white shadow-md' : 'text-gray-400 hover:bg-gray-50'}`} title="رسم غرفة (مربع)"><LayoutTemplate className="w-5 h-5" /></button>
           <div className="w-[1px] h-6 bg-gray-200 mx-1"></div>
           <button onClick={() => setShowFurnitureMenu(true)} className={`p-3 rounded-full transition-all ${showFurnitureMenu ? 'bg-blue-600 text-white shadow-md' : 'text-gray-400 hover:bg-gray-50'}`} title="إضافة أثاث"><Armchair className="w-5 h-5" /></button>
           <div className="w-[1px] h-6 bg-gray-200 mx-1"></div>
           <button onClick={() => setMode('PAN')} className={`p-3 rounded-full transition-all ${mode === 'PAN' ? 'bg-black text-white shadow-md' : 'text-gray-400 hover:bg-gray-50'}`} title="تحريك"><Hand className="w-5 h-5" /></button>
        </div>
      </div>
    </div>
      {show3D && (
          <Suspense fallback={<div className="fixed inset-0 bg-white z-[100] flex items-center justify-center font-bold text-gray-500">جاري تحميل العرض ثلاثي الأبعاد...</div>}>
            <RoomPlanner3D nodes={nodes} walls={walls} objects={objects} onClose={() => setShow3D(false)} />
          </Suspense>
      )}

    </div>
  );
}
